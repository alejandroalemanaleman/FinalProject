 # Practice 2: Incorporation of data into the system architecture.

**Subject:** Development of Applications for Data Science

**Course:** 2nd year

**Degree:** Engineering and Data Science

**School:** School of Computer Engineering

**University:** University of Las Palmas de Gran Canaria

## Instructions before running the program
1. Download the latest release from the Git repository and unzip both folders ("prediction-provider" and "event-store-builder"). Open two terminal tabs, each pointing to "prediction-provider" and "event-store-builder".
2. In the "event-store-builder" tab, execute the command `java -jar event-store-builder-1.0-SNAPSHOT.jar argument`, replacing "argument" with the desired output files location. For example, if you want to save them in your Downloads folder on macOS, the command should resemble this: "/Users/nameofUser/Downloads". 
3. Once completed, proceed to the "prediction-provider" tab and run `java -jar prediction-provider-1.0-SNAPSHOT.jar argument`, replacing "argument" with the OpenWeather API key for "Call 5 day / 3-hour forecast data." Execute the command after writing it to complete the process. These steps ensure a successful program execution.

Link to OpenWeatherMap API: https://openweathermap.org/forecast5

## Summary of Functionality
The program is designed to periodically retrieve weather data for eight Canary Islands from the OpenWeatherMap API every six hours. The collected information includes essential details such as temperature, precipitation probability, humidity, cloud coverage, and wind speed. Once obtained, this weather data is transmitted as events to a message broker. Subsequently, the "event-store-builder" component subscribes to the corresponding topic on the broker and efficiently stores the received events in the "event-store" directory.

Each weather event is systematically organized into individual files, with filenames derived from their timestamps. In summary, the program establishes a robust workflow for obtaining, processing, and storing weather data, ensuring a structured and efficient approach to handling the information generated by the OpenWeatherMap API.

## Resources Used

- **Development Environments:**
  The application was developed using IntelliJ IDEA, a popular integrated development environment (IDE) for Java. IntelliJ IDEA stands out for Java development. Its user-friendly interface and seamless integration with version control systems ensure a streamlined and efficient development process.

- **Version Control Tools:**
  Git, a crucial version control system, managed the project's source code, ensuring a reliable change history. Git commands, including commit, played a important role in maintaining an organized and collaborative development process.

- **Dependencies management:**
  The provided Maven Project Object Model (POM) file is essential for managing the project. In this file, key details like project organization, name, and version are defined. The properties section specifies Java versions and encoding.
  Dependencies are crucial external libraries needed for the project. Notably, it includes Jsoup for HTML manipulation, and Gson for JSON processing and for the Java Message Service (JMS), Apache ActiveMQ library. 

- **Documentation Tools:**
  The project documentation was crafted using Markdown, a lightweight markup language that offers simplicity and readability. Markdown provides an easy-to-learn syntax for formatting text, making it an efficient choice for creating clear and well-organized documentation.

## Design

The following design patterns and principles have been applied:

**Single Responsibility Principle (SRP):** Each class should have only one reason to change. For example, the `OpenWeatherMapSupplier` class is responsible for interacting with the OpenWeatherMap API, while the `JMSWeatherStore` class is responsible for sending to the broker the events.

**Open/Closed Principle (OCP):** Classes should be designed to be extended without modifying their original source code. For example, new locations (`Location`) or weather providers (`WeatherSupplier`) can be added without changing existing classes.

**Observer Pattern:**
The use of Timer and TimerTask in the Main class indicates a form of periodic observation or event scheduling. The WeatherController extends TimerTask, and its run method is periodically executed, triggering weather-related tasks.

## Class Diagram
#### Prediction-provider
<img width="650" alt="Second Step" src="https://github.com/alejandroalemanaleman/Practice2/assets/145342887/9c61b48d-0593-403d-bc66-60c8105cfcbd">


#### Event-store-builder
<img width="650" alt="Second Step" src="https://github.com/alejandroalemanaleman/Practice2/assets/145342887/d7f3ce29-5d4d-4ac8-9236-aa3cead52c9a">


### Dependency Relationships

**- Prediction-provider**

#### `Main`:

**Dependencies:**
- **`Timer`:** It schedules tasks and is utilized to execute the `WeatherController` periodically.
- **`WeatherController`:** It orchestrates the flow of the application and manages the periodic execution of weather-related tasks.

#### `WeatherController`:

**Dependencies:**
- **`OpenWeatherMapSupplier`:** It depends on this class to obtain weather information.
- **`JMSWeatherStore`:** It depends on this class to store the retrieved weather information using JMS.

**Execution:**
- Calls the `execute` method, which, in turn, triggers the retrieval and storage of weather data.

#### `OpenWeatherMapSupplier`:

**Dependencies:**
- **`Location`:** It works with instances of the `Location` class to construct API URLs and manage location-related data.
- **External libraries (`Gson`, `Jsoup`):** It utilizes Gson for JSON parsing and Jsoup for connecting to the OpenWeatherMap API.

#### `JMSWeatherStore`:

**Dependencies:**
- **`Weather`:** It interacts with instances of the `Weather` class to convert and store weather data in JMS.
- **External libraries (`ActiveMQ`, `JMS`):** It uses ActiveMQ and JMS for interacting with the messaging system.

#### `Location`:

**Dependencies:** None (simple data-holding class).

#### `Weather`:

**Dependencies:**
- **`Location`:** It contains information about the location associated with the weather data.
- **`Instant`:** It uses `Instant` for timestamps associated with when the weather was checked.

#### `WeatherStore`:

**Dependencies:**
- **`Weather`:** It defines the contract for storing weather information.

#### `WeatherSupplier`:

**Dependencies:**
- **`Weather`:** It defines the contract for obtaining weather information.

These dependency relationships illustrate how each class collaborates to fulfill its specific role in the overall weather information retrieval and storage process .<br><br>


**- Event-store-builder**

#### `Main`:

**Dependencies:**
- **`TopicSubscriber`:** It relies on this class to handle the subscription and processing of messages from a JMS topic.

#### `TopicSubscriber`:

**Dependencies:**
- **`EventStoreBuilder`:** It depends on this abstraction to save the received JMS messages.
- **External libraries (`ActiveMQ`, `JMS`):** It utilizes ActiveMQ and JMS for interacting with the messaging system.

**Execution:**
- Calls the `start` method, which initiates the JMS connection, creates a durable subscriber, and processes incoming messages.

#### `EventStoreBuilder`:

**Dependencies:**
- **`SaveException`:** It throws this exception when there's an issue saving the event.

#### `FileEventStoreBuilder`:

**Dependencies:**
- **`EventStoreBuilder`:** It implements this interface to provide the functionality of saving events.
- **External libraries (`Gson`):** It uses Gson for JSON parsing.

**Execution:**
- Calls methods from `Gson` to parse and extract information from the incoming JMS messages.
- Utilizes Java I/O operations for storing events in files.

These dependency relationships illustrate how each class collaborates to fulfill its specific role in the overall event subscription and processing flow.
